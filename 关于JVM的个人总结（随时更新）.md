# **关于JVM的个人总结**（随时更新）

前言:最近终于零零散散的看完了《深入理解java虚拟机》这本书，对于一个工作了很多年的java码农，一直对于java的运行机制和内存管理有着浓厚的兴趣，在这里简单的总结一下吧。

## 1.java内存模型

![](C:\Users\Wang\Desktop\播客图片\timg.jpg)

### 程序计数器

是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储

### Java虚拟机栈

描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息

### 本地方法栈

属线程私有内存区域，本地方法栈与虚拟机栈发挥的功能非常类似，只是虚拟机栈为虚拟机执行java方法而服务，而本地方法栈为虚拟机执行**native方法**而服务。当本地方法栈中没有内存满足实例分配需求，会抛出StackOverflowError和OutOfMemoryError异常

### 方法区

储存已被JVM加载的类信息、常量、静态变量、即时编译后的代码等

### 堆

虚拟机启动时创建，占用区域最大，用于存放对象实例，可以处理不连续的内存空间，可扩展，是GC机制管理的主要区域，所以也被叫做GC堆。由于现在收集器基本都采用分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；在细致一点的有Eden空间、From Survivor空间、To Survivor空间

对象从新生代变成老年代的判定方法:每经历一次Minor GC（复制算法回收对象）就会让对象的年龄加一，当对象年龄为15时就会把新生代的对象放入老年代中。如果Survivor区中的存放不下的对象就会放入老年代中：对象会优先在Eden区中分配，而后通过一次Minor GC就让对象进入Survivor区中，当Survivor区中存放不下该对象时就会将该对象放入老年代。新生成的大对象也会直接放入老年代中（可以通过-XX:+PretenuerSizeThreshold设置）超过这个size的对象一生成就会放入老年代。

## 2.垃圾收集算法

### 复制算法

它将可用内存空间划分为一块较大的Eden空间和两块较小的From Survivor（S0）和To Survivor（S1）空间。每次使用时只使用Eden和其中一块S区。比如这次使用的是S0区。回收时将Eden和S0区中的中还存活的对象一次性复制到S1中最后再清理Eden和S0中的对象，HotSpot虚拟机默认Eden:S0:S1之间大小比例是8:1:1，这是因为新生代中对象大多数甚至98%的都是“朝生夕死”。如果S区的大小不够那么就会依赖老年代的内存进行分配担保

### 标记—清理与标记—整理

标记—清理算法：首先标记出所有需要回收的对象，在标记完成之后统一回收所有标记的对象

标记—整理算法：先标记所有可回收对象，让存活的对象向一端移动，然后直接清理掉端边界以外的内存

#### 垃圾回收器

<img src="C:\Users\Wang\Desktop\播客图片\1344248-20180318001758565-463873178.png" style="zoom:80%;" />

## 3.常用内存设置参数总结

​    -Xms：设置jvm内存的初始大小
​    -Xmx：设置jvm内存的最大值
​    -Xmn：设置新域的大小（这个似乎只对 jdk1.4来说是有效的，后来就废弃了）
​    -Xss：设置每个线程的堆栈大小(也就是说,在相同物理内存下，减小这个值能生成更多的线程)
​    -XX：NewRatio :设置新域与旧域之比，如-XX：NewRatio = 4就表示新域与旧域之比为1：4
​    -XX:NewSize：设置新域的初始值
​    -XX:MaxNewSize ：设置新域的最大值
​    -XX:MaxPermSize：设置永久域的最大值
​    -XX:SurvivorRatio=n:设置新域中Eden区与两个Survivor区的比值。（Eden区主要是用来存放新生的对象，而两个Survivor区则用来存放每次垃圾回收后存活下来的对象

## 4.对于volatile的思考

1.保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成

2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）

在不符合下述场景中，仍然需要使用加锁的方式来保证原子性

1.运算结果并不依赖变量的当前值。或者能够确保只有单一的线程修改变量的值

2.变量不需要与其他的状态变量共同参与不变约束

## 5.类的加载顺序

BootStrap ClassLoader

Extension ClassLoader

Application ClassLoader

## 6.双亲委派机制

类加载器会向上委托父类加载器，若成功完成类加载任务，则成功返回，避免了类的重复加载，保护核心API





















